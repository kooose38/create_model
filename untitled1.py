# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Zt5rWDCHw8_RIvj1OlN9nfo2E6Tax0Z6
"""

import torch 
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
import cv2 
import matplotlib.pyplot as plt

!pip install -q pytorch-lightning

import pytorch_lightning as pl
import torchvision

img=cv2.imread('image2.jpg')
img

plt.imshow(img)

img=cv2.cvtColor(img,cv2.COLOR_BGR2RGB)
plt.imshow(img)
plt.show()

from PIL import Image

img=Image.open('image2.jpg')
plt.imshow(img)
plt.show()

img

x=np.array(img)
x.shape

img=cv2.imread('image2.jpg')

img=cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)
plt.imshow(img,cmap='gray')

img.shape

img

kernel=np.array([
                 [-1,0,1],[-1,0,1],[-1,0,1]
])

img_conv=cv2.filter2D(img,-1,kernel)
img_conv

plt.imshow(img_conv,cmap='gray')
plt.show()

kenel=np.array([
                [-1,-1,-1],[0,0,0],[1,1,1]
])

img3=cv2.filter2D(img,-1,kernel)
plt.imshow(img3,cmap='gray')

from torchvision import transforms

transform=transforms.Compose([
                              transforms.ToTensor(),
])
train=torchvision.datasets.MNIST(root='data',train=True,download=True,transform=transform)
train

len(train)

train[0][0].shape

train[0][1]

img=np.transpose(train[0][0],(1,2,0))
img.shape

img=img.reshape(28,28)
img.shape

plt.imshow(img,cmap='gray')

for i in range(20):
  print(np.array(train[i][1]).unique())

x=train[0][0]
x.shape

conv=nn.Conv2d(1,4,3,padding=1)
conv

conv.weight

conv.bias

x=x.reshape(1,1,28,28)
x.shape



x=F.max_pool2d(x,2,2)

x.shape

num=x.shape[1]*x.shape[2]*x.shape[3]
num

x=x.view(-1,num)
x.shape

fc=nn.Linear(num,10)
fc

bt1=nn.BatchNorm1d(10)
bt1

x=fc(x)

x=F.relu(x)

t=train[0][1]
t

t

F.cross_entropy(torch.argmax(x),t)

x

from pytorch_lightning.metrics.functional import accuracy

test=torchvision.datasets.MNIST(root='data',download=True,train=False,transform=transform)
len(test)

torch.manual_seed(0)

n_train=int(len(train)*0.8)
n_val=len(train)-n_train

train,val=torch.utils.data.random_split(train,[n_train,n_val])
len(train),len(val)

batch_size=256

train_loader=torch.utils.data.DataLoader(train,batch_size,shuffle=True,drop_last=True)
val_loader=torch.utils.data.DataLoader(val,batch_size)
test_loader=torch.utils.data.DataLoader(test,batch_size)

len(train_loader),len(val_loader),len(test_loader)

class Net(pl.LightningModule):

  def __init__(self):
    super(Net,self).__init__()
    self.conv1=nn.Conv2d(1,64,3,padding=1)
    self.conv2=nn.Conv2d(64,128,3,padding=1)
    self.conv3=nn.Conv2d(128,256,3,padding=1)

    self.fc1=nn.Linear(256*7*7,256*7*7)
    self.fc2=nn.Linear(256*7*7,10)

  def forward(self,x):
    x=self.conv1(x)
    x=F.relu(x)
    x=F.max_pool2d(x,2,2)

    x=self.conv2(x)
    x=F.relu(x)
    x=F.max_pool2d(x,2,2)

    x=self.conv3(x)
    x=F.relu(x)

    x=x.view(-1,256*7*7)
    x=F.relu(x)
    x=self.fc1(x)
    x=self.fc2(x)

    return x

  def training_step(self,batch,batch_idx):
    x,t=batch
    y=self.forward(x)
    loss=F.cross_entropy(y,t)
    return loss

  def validation_step(self,batch,batch_idx):
    x,t=batch
    y=self.forward(x)
    loss=F.cross_entropy(y,t)
    acc=accuracy(y,t)
    self.log('val_acc',acc,on_step=True,on_epoch=True)
    self.log('val_loss',loss,on_step=True,on_epoch=True)
    return loss

  def test_step(self,batch,batch_idx):
    x,t=batch
    y=self.forward(x)
    loss=F.cross_entropy(y,t)
    acc=accuracy(y,t)
    self.log('test_acc',acc,on_step=True,on_epoch=True)
    self.log('test_loss',loss,on_step=True,on_epoch=True)
    return loss


  def configure_optimizers(self):
    optimizer=torch.optim.SGD(self.parameters(),lr=0.01)
    return optimizer

net=Net()
pl.seed_everything(0)
torch.manual_seed(0)

trainer=pl.Trainer(gpus=1,max_epochs=5)
trainer.fit(net,train_loader,val_loader)

# Commented out IPython magic to ensure Python compatibility.
# %load_ext tensorboard
# %tensorboard --logdir lightning_logs/

trainer.callback_metrics

trainer.test(test_dataloaders=test_loader)

net.state_dict().keys()

torch.save(net.state_dict(),'mnist.pt')

net=Net()
net.load_state_dict(torch.load('mnist.pt'))

sample=train[0][0].reshape(1,1,28,28)
sample.shape

pred=net.forward(sample)
pred

torch.argmax(pred)

train[0][1]

