# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X-4BwFTDslqBdVeUVJ-MA_ykti9Q-Mnf
"""

!pip install -q pytorch_lightning

import torch,torchvision
import numpy as np 
import matplotlib.pyplot as plt 
import torch.nn as nn
import torch.nn.functional as F
from pytorch_lightning.metrics.functional import accuracy
from torchvision import transforms
from torchvision.datasets import CIFAR10
import pandas as pd

import cv2
import pytorch_lightning as pl

transform=transforms.Compose([
                              transforms.ToTensor(),
])
train_val=CIFAR10(root='data',download=True,train=True,transform=transform)
test=CIFAR10(root='data',download=True,train=False,transform=transform)

n_train=int(len(train_val)*0.8)
n_val=len(train_val)-n_train
torch.manual_seed(0)
pl.seed_everything(0)
train,val=torch.utils.data.random_split(train_val,[n_train,n_val])
len(train),len(val),len(test)

fig,axes=plt.subplots(5,5,figsize=(16,10))

ax=axes.ravel()

for i in range(25):
  x=np.array(train[i][0])
  x=np.transpose(x,(1,2,0))
  ax[i].imshow(x)

plt.show()

train[0][0].shape

img=cv2.imread('image2.jpg')
img=cv2.cvtColor(img,cv2.COLOR_BGR2RGB)
plt.imshow(img)
plt.show()

batch_size=256

train_loader=torch.utils.data.DataLoader(train,batch_size,shuffle=True,drop_last=True)
val_loader=torch.utils.data.DataLoader(val,batch_size)
test_loader=torch.utils.data.DataLoader(test,batch_size)

train[0][0].shape

class Net(pl.LightningModule):
  def __init__(self):
    super(Net,self).__init__()
    self.conv=nn.Conv2d(3,32,3,padding=1)
    self.conv1=nn.Conv2d(32,64,3,padding=1)
    self.conv2=nn.Conv2d(64,128,3,padding=1)

    self.fc=nn.Linear(128*4*4,128)
    self.fc1=nn.Linear(128,10)
#　標準化
    self.bt1=nn.BatchNorm2d(32)
    self.bt2=nn.BatchNorm2d(64)
    self.bt3=nn.BatchNorm2d(128)

# 不要なデータを含めない（過学習）
    self.dropout=nn.Dropout2d(p=0.5)

  def forward(self,x):
    x=self.conv(x)
    x=self.bt1(x)
    x=F.relu(x)
    x=F.max_pool2d(x,2,2)

    x=self.conv1(x)
    x=self.bt2(x)
    x=F.relu(x)
    x=F.max_pool2d(x,2,2)

    x=self.conv2(x)
    x=self.bt3(x)
    x=F.relu(x)
    x=F.max_pool2d(x,2,2)

    x=x.view(-1,128*4*4)
    x=self.dropout(x)
    x=F.relu(x)
    x=self.fc(x)
    x=self.fc1(x)
    return x

  def training_step(self,batch,batch_idx):
    x,t=batch
    y=self.forward(x)
    loss=F.cross_entropy(y,t)
    return loss

  def validation_step(self,batch,batch_idx):
    x,t=batch
    y=self.forward(x)
    loss=F.cross_entropy(y,t)
    acc=accuracy(y,t)
    self.log('val_acc',acc,on_step=True,on_epoch=True)
    self.log('val_loss',loss,on_step=True,on_epoch=True)
    return loss

  def test_step(self,batch,batch_idx):
    x,t=batch
    y=self.forward(x)
    loss=F.cross_entropy(y,t)
    acc=accuracy(y,t)
    self.log('test_acc',acc,on_step=True,on_epoch=True)
    self.log('test_loss',loss,on_step=True,on_epoch=True)
    return loss


  def configure_optimizers(self):
    #極端なパラメータを0にする
    optimizer=torch.optim.Adam(self.parameters(),lr=0.01,weight_decay=0.001)
    return optimizer

net=Net()
x=train[0][0]
x=x.reshape(1,3,32,32)
net.forward(x)

net=Net()
trainer=pl.Trainer(gpus=1,max_epochs=5)
trainer.fit(net,train_loader,val_loader)

# Commented out IPython magic to ensure Python compatibility.
# %load_ext tensorboard
# %tensorboard --logdir lightning_logs/

trainer.test(test_dataloaders=test_loader)

trainer.callback_metrics

